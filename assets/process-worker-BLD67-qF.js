(function(){"use strict";const x=c=>{const e=[],t=(n,i)=>{if(i===c){e.push(n);return}t([...n,0],i+1),t([...n,1],i+1)};return t([],0),e};class w{constructor(e,t=null){this.index=e,this.outputValue=t}}class F extends w{constructor(e){super(e)}}class b extends w{constructor(e,t,n){super(n),this.mincode=e,this.inputsFE=t,this.numInputs=t.length,this.state="not computed",this.delayFE=void 0}getInputValues(e){const t=[],n=[];for(let i=0;i<this.numInputs;i++){let u=this.inputsFE[i],s=e.instancesFE[u];t[i]=s.outputValue,s.outputValue==null&&n.push(i)}return[t,n]}computeFunction(e,t){let n=[];t?n=t.map((s,o)=>s===null?o:-1).filter(s=>s!==-1):[t,n]=this.getInputValues(e);const i=x(n.length);let u=new Set;for(const s of i){n.forEach((f,l)=>{t[f]=s[l]});const o=this.mincode.toString(2).padStart(2**this.numInputs,"0"),r=parseInt(t.join(""),2),a=parseInt(o[r],2);if(u.add(a),u.size>1)break}return u.size===1?[...u][0]:null}}class N extends w{constructor(e){super(e),this.outputValue=0}}class D extends b{constructor(e,t,n,i){super(e,t,n),this.inverses=i}getInputValues(e){const t=[],n=[];for(let i=0;i<this.numInputs;i++){let u=this.inputsFE[i],s=e.instancesFE[u];t[i]=s.outputValue==null?s.outputValue:s.outputValue^this.inverses[i],s.outputValue==null&&n.push(i)}return[t,n]}}class O extends D{constructor(e,t,n){super(1,e,t),this.inverses=n}}class V{constructor(){this.number=void 0,this.format=void 0,this.countInputs=0,this.countFE=0,this.instancesFE={},this.outputNums=[],this.inputsNums=[],this.outputValues={},this.depth=void 0,this.delay=void 0,this.signDelay=void 0,this.allPaths=[],this.depthsDict={},this.xDepthsDict={}}validateCircuit(e,t){if(!e||e.format!=="fcircuit")throw new Error(`Invalid format or circuit number: ${t}`)}parseCircuit(e,t){const n=e.get(t);this.validateCircuit(n,t),this.format=n.format,this.number=n.number,this.countInputs=n.countInputs,this.countFE=n.countFE,this.outputNums=n.outputNums,this.creatingElements(n);for(const i of Object.keys(this.instancesFE)){const u=this.instancesFE[i];let s;if(u.index<=this.countInputs)continue;let o=!0;for(const r of u.inputsFE)if(!(r in this.instancesFE)||r===u.index){s=r,o=!1;break}if(!o)throw new Error(`Invalid input index (${s}) of a functional element (${u.index})`)}return n}creatingElements(e){for(let t=1;t<this.countInputs+1;t++)this.inputsNums.push(t),this.instancesFE[t]=new F(t);for(let t=0;t<e.countFE;t++){let n=e.instancesFE[t];this.instancesFE[n.id]=new b(n.mincode,n.inputsFE,n.id)}}findAllRoots(){const e=new Set(Object.keys(this.instancesFE).map(Number));for(const t of Object.values(this.instancesFE))if(t.index<=this.countInputs)e.delete(t.index);else for(const n of t.inputsFE)e.delete(n);return Array.from(e)}dfs(e,t=new Set,n=[]){t.add(e.index),n.push(e.index);let i=[];if(e.index<=this.countInputs)i.push([...n]);else for(const u of e.inputsFE){const s=this.instancesFE[u];t.has(s.index)||(i=i.concat(this.dfs(s,t,n)))}return n.pop(),t.delete(e.index),i}findAllPaths(){const e=this.findAllRoots();let t=[];for(const n of e){const i=this.instancesFE[n];t=t.concat(this.dfs(i))}return t}calculateDepth(e){if(e.length===0)throw new Error("allPaths array is empty");return Math.max(...e.map(n=>n.length))-1}buildDepthsDict(e){const t={};if(e.length===0)throw new Error("allPaths array is empty");for(const n of e)for(let i=0;i<n.length;i++){const u=n.length-1-i,s=n[i];let o=!1;for(const r in t)if(r>u&&t[r].has(s)){o=!0;break}if(!o){for(const r in t)r<u&&t[r].has(s)&&t[r].delete(s);t[u]||(t[u]=new Set),t[u].add(s)}}return t}buildXDepthsDict(e){const t={};if(e.length===0)throw new Error("allPaths array is empty");for(const n of e)for(let i=0;i<n.length;i++){const u=n.length-1-i,s=n[i];t[u]||(t[u]=new Set),t[u].add(s)}return t}initializeCircuit(e=0){return this._initializeCircuitInternal(e,0)}_initializeCircuitInternal(e,t){if(e<0||e>2**this.countInputs-1||isNaN(e))throw new Error(`set number must be in range 0..${2**this.countInputs-1}`);let i=x(this.countInputs)[e];return Object.keys(this.instancesFE).slice(t,this.countInputs+1).forEach((u,s)=>{const o=this.instancesFE[u];o.outputValue=i[s]}),i}simulateCircuit(e){const t={};if(Object.keys(e).length===0)throw new Error("depths dict is empty");for(const n in e){if(n==="0")continue;const i=e[n],u={},s={};i.forEach(o=>{const r=this.instancesFE[o];if(r.state!=="computed"){const a=r.computeFunction(this);s[o]=a,u[r.index]={state:a===null?"uncertain":"computed",outputValue:a}}else u[r.index]={state:r.state,outputValue:r.outputValue}});for(const[o,r]of Object.entries(s)){const a=this.instancesFE[o];r!==null?(a.state="computed",a.outputValue=r):a.state="uncertain"}t[n]=u}return t}calculateOutput(){return Object.values(this.instancesFE).filter(t=>this.outputNums.includes(t.index)).forEach(t=>{const n=t.index;if(this.instancesFE[n].outputValue==null)throw new Error("output value has not been calculated yet");this.outputValues[n]=this.instancesFE[n].outputValue}),this.outputValues}calculateDelay(e){if(Object.keys(e).length===0)throw new Error("states dict is empty");let t=[];const n=new Set;for(const u of Object.keys(e))for(const s of Object.keys(e[u]))e[u][s].state==="computed"&&!n.has(s)&&(this.instancesFE[s].delayFE=u,n.add(s),this.outputNums.includes(+s)&&t.push(+u));const i=Math.max(...t);return this.delay=i,i}searchSignChains(e){const t=(o,r,a,f,l,E)=>o.has(r)?a[f].some(d=>d.length>l&&d[l]===E):!1;if(e.length===0)throw new Error("method searchSignChains: allPaths array is empty");const n={},i=[],u={},s=new Set;return e.forEach(o=>{if(!this.outputNums.includes(o[0])||o.includes(0))return;const r=o.join("-"),a=[...o].reverse().join("-");let f;r in n?(f=n[r].length,n[r].push([])):(f=0,n[r]=[[]]);let l=!1;const E=[];for(const m of o){if(m<=this.countInputs)continue;const d=o.indexOf(m);let g=[],I=[];const h=this.instancesFE[m];new Set(h.inputsFE).size!==h.inputsFE.length&&s.add(m),g=h.getInputValues(this)[0],I=[...g];for(let p=0;p<h.inputsFE.length;p++)if(o[d+1]===h.inputsFE[p]&&!t(s,m,n,r,d,+p)){E.push(`${h.inputsFE[p]}-${p}-${h.index}`),n[r][f].push(+p),I[p]=1-g[p];const S=h.outputValue,y=h.computeFunction(null,I);if(S!==y)l=!0;else{l=!1;return}break}}l&&(u[a]||(u[a]=[]),u[a].push(E.reverse().join("_")),i.push(o))}),[i,u]}calculateSignDelay(e){return e.length===0?0:this.calculateDepth(e)}}class v extends V{constructor(){super(),this.outputInversion}validateCircuit(e,t){throw new Error("Method validateCircuit must be implemented.")}parseCircuit(e,t){const n=super.parseCircuit(e,t);this.outputNums=n.output,this.outputInversion=n.inversion}creatingElements(e){throw new Error("Method creatingElements must be implemented.")}calculateOutput(){const e=this.outputNums[0];if(this.instancesFE[e].outputValue==null)throw new Error("output value has not been calculated yet");return this.outputValues[e]=this.instancesFE[e].outputValue^this.outputInversion,this.outputValues}}class $ extends v{constructor(){super(),this.outputInversion}validateCircuit(e,t){if(!e||e.format!=="aig")throw new Error(`Invalid format or circuit number: ${t}`)}creatingElements(e){for(let t=1;t<this.countInputs+1;t++)this.inputsNums.push(t),this.instancesFE[t]=new F(t);for(let t=0;t<e.countFE;t++){let n=e.instancesFE[t];this.instancesFE[n.id]=new O(n.inputsFE,n.id,n.inverses)}}}class j extends D{constructor(e,t,n){super(23,e,t),this.inverses=n}}class k extends v{constructor(){super(),this.outputInversion}validateCircuit(e,t){if(!e||e.format!=="mig")throw new Error(`Invalid format or circuit number: ${t}`)}creatingElements(e){this.instancesFE[0]=new N(0);for(let t=1;t<this.countInputs+1;t++)this.inputsNums.push(t),this.instancesFE[t]=new F(t);for(let t=0;t<e.countFE;t++){let n=e.instancesFE[t];this.instancesFE[n.id]=new j(n.inputsFE,n.id,n.inverses)}}initializeCircuit(e=0){return this._initializeCircuitInternal(e,1)}}function C(c){switch(c){case"fcircuit":return new V;case"mig":return new k;case"aig":return new $;default:throw new Error(`Unknown format: ${c}`)}}function A(c){return`[
`+c.map(e=>{const t=e.setResults.map(n=>`        ${JSON.stringify(n)}`).join(`,
`);return`  {
    "number": ${e.number},
    "depth": ${e.depth},
    "setResults": [
${t}
    ]
  }`}).join(`,
`)+`
]`}let P=!1;function M(c){if(!Array.isArray(c))throw new Error("The JSON data is not an array");if(!c||!c.length)throw new Error("The JSON data is empty");const e=new Map;c.forEach(u=>{e.set(u.number,u)});const t=[],n=[];let i=0;for(const u of c)try{let s,o;const r=[],a=2**u.countInputs,f=u.format;s=C(f),s.parseCircuit(e,+u.number);const l=s.findAllPaths(),E=s.buildXDepthsDict(l);o=s.calculateDepth(l);for(let d=0;d<a;d++){let g={};s=C(f),s.parseCircuit(e,+u.number),s.initializeCircuit(d),g=s.simulateCircuit(E);const I=s.calculateOutput(),h=s.calculateDelay(g),[p,S]=s.searchSignChains(l),y=s.calculateSignDelay(p);r.push({inputSet:d.toString(2).padStart(s.countInputs,"0"),outputValue:I,delay:h,signDelay:y})}const m={number:u.number,depth:o,setResults:r};t.push(m),i++}catch(s){console.error(`Error processing circuit ${u.number}:`,s),n.push({number:u.number,error:`Error: ${s.message}`})}return{resultData:A(t),errorData:n}}self.onmessage=function(c){const e=c.data;try{const{resultData:t,errorData:n}=M(e);self.postMessage({resultData:t,errorData:n})}catch(t){self.postMessage({error:t.message})}}})();
